[{"content":"图像读取 1 2 3 4 5 6 7 8 9 10 11 12 # 导包 import cv2 import numpy as np from numpy.ma import hstack# 用于横向拼接图片 from numpy.ma import vstack# 用于纵向拼接图片 def cv_show(img): cv2.imshow(\u0026#34;topic:zhenquanxu1\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() image1 = cv2.imread(\u0026#34;./pictures/plane.jpg\u0026#34;) image2 = cv2.imread(\u0026#34;./pictures/plane.jpg\u0026#34;,cv2.IMREAD_GRAYSCALE) cv_show(image2) 视频读取 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import cv2 import numpy as np vc = cv2.VideoCapture(r\u0026#34;C:\\Users\\zhenq\\Videos\\03.mp4\u0026#34;) # 图像的读取 # 异常处理 if vc.isOpened(): oepn,frame = vc.read() else: open = False # 使用循环体对每一帧图像进行读取 while open: ret,frame=vc.read() # frame位置是帧，如果视频没有了，frame变为None,视频退出播放 if frame is None: break # ret 表示程序能否读取视频 if ret == True: cv2.imshow(\u0026#34;这是一个测试\u0026#34;,cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY))# 对每一帧进行灰度处理 if cv2.waitKey(10)\u0026amp;0xFF==27: # 程序等待10毫秒，在这个时间内检测用户键盘输入，esc的ASCII码是27.检测后进入下一次的while循环 break vc.release() cv2.destroyAllWindows() 图像的灰度处理、截取、颜色通道的提取、调整大小与融合、阈值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import cv2 import numpy as np def cv_show(img): cv2.imshow(\u0026#34;topic:zhenquanxu1\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() # 图像的灰度处理方法一：在imread中添加相关参数，这钟方法不建议使用，此处不再写 # 图像的灰度处理方法二：将传入的图像进行二次处理,这种方法可以分别得到原图和灰度图，方便展示 image = cv2.imread(r\u0026#34;./pictures/GEM.png\u0026#34;) image_gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY) \u0026#34;\u0026#34;\u0026#34; 截取图像，在使用imread后，得到的是一个矩阵（或者说是一个list[]列表），可以使用切片的方法从里面得到部分数据 对于BGR彩色图，这个list是一个\u0026#34;[[[B,G,R]]]\u0026#34;,比如下面这个3*3的图片 [[[ 62 62 62] [ 56 56 56] [ 33 33 33]] [[126 126 126] [ 58 58 58] [ 57 57 57]] [[ 61 61 61] [ 94 94 94] [217 217 217]]] 可以横向进行表示，更容易理解： [[[ 62 62 62],[ 56 56 56],[ 33 33 33]] [[126 126 126],[ 58 58 58],[ 57 57 57]] [[ 61 61 61],[ 94 94 94],[217 217 217]]] list[0:2]可以把0行、1行拿出来，也就是列表中的第一行和第二行 list[0:2][0:1]可以把列表中前两行、第一列列拿出来。当然了list[0:2,0:1]和list[0:2][0:1]是一样的。 进一步的说[0:2]是图片的高，[0:1]是图片的宽。在cv2中图像的坐标原点在左上角，水平方向是w轴，竖直方向是h，要理解图像和矩阵之间的转换关系。 每一个像素点由三个数字表示；对于灰度图，一个数字就可以表示一个像素点。 \u0026#34;\u0026#34;\u0026#34; # 在理解了图像和矩阵或者说列表之间的关系，下面的就很好理解了。对列表进行三次切片可以得到相应的BGR颜色值。 #只保留R.注意在cv2中顺序是BGR，不是RGB image[:,:,0]=0 image[:,:,1]=0 \u0026#34;\u0026#34;\u0026#34; cv2.resize(image1,(100,100)) #调整大小为100*100 cv2.resize(image1,(0,0),fx=2,fy=2) #图像沿着x方向y方向进行拉伸 cv2.addWeighted(image,0.5,image1,0.5,0) #res=A*image+B*image1+C,在这里A,B,C分别是0.5，0.5，0 \u0026#34;\u0026#34;\u0026#34; 边界填充 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import cv2 import numpy as np import matplotlib.pyplot as plt plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False def cvshow(image): cv2.imshow(\u0026#34;this is a top\u0026#34;,image) cv2.waitKey(0) cv2.destroyAllWindows() image1 = cv2.imread(r\u0026#34;./pictures/03.png\u0026#34;)# 图片大小(746, 1374, 3) # 为了进行边界填充，首先将图片进行切割。 image2 = image1[0:512,0:512] # 边界填充 top,bottom,left,right =(100,100,100,100) # 1.replicate法填充 replicate = cv2.copyMakeBorder(image2,top,bottom,left,right,borderType=cv2.BORDER_REPLICATE) # 2.reflect 法填充 reflect = cv2.copyMakeBorder(image2,top,bottom,left,right,borderType=cv2.BORDER_REFLECT) # 3.reflect101 法填充 reflect101 = cv2.copyMakeBorder(image2,top,bottom,left,right,borderType=cv2.BORDER_REFLECT_101) # 4.wrap法填充 wrap = cv2.copyMakeBorder(image2,top,bottom,left,right,borderType=cv2.BORDER_WRAP) # 5.constant法填充 constant = cv2.copyMakeBorder(image2,top,bottom,left,right,borderType=cv2.BORDER_CONSTANT,value=0) #图片展示，其中\u0026#34;231\u0026#34;，2表示总行数；3表示总列数；1表示这六个位置中的第一个位置。 plt.figure(figsize=(10, 6)) plt.subplot(231),plt.imshow(replicate),plt.title(\u0026#39;replicate法填充\u0026#39;) plt.subplot(232),plt.imshow(reflect),plt.title(\u0026#39;reflect法填充\u0026#39;) plt.subplot(233),plt.imshow(reflect101),plt.title(\u0026#39;reflect101法填充\u0026#39;) plt.subplot(234),plt.imshow(wrap),plt.title(\u0026#39;wrap法填充\u0026#39;) plt.subplot(235),plt.imshow(constant),plt.title(\u0026#39;constant法填充\u0026#39;) plt.show(plt) 数值计算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import numpy as np import cv2 import matplotlib.pyplot as plt def cvshow(img): cv2.imshow(\u0026#34;image\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() image1 = cv2.imread(r\u0026#34;./pictures/opencv_logo.jpg\u0026#34;) image2 = cv2.imread(r\u0026#34;./pictures/plane.jpg\u0026#34;) image = image2[0:250,0:250] # 使image与image1大小相同，以保证矩阵能正常进行运算 def fun1(): image = image2[0:250,0:250] cv2.imshow(\u0026#34;6\u0026#34;,image+100) # 将矩阵中的每一个数字加100 cv2.imshow(\u0026#34;6\u0026#34;,image+image1) # 大小相同的两个矩阵相加，超过255的部分取余数 cv2.add(image1,image) #大小相同的两个矩阵相加，超过255的统一取为255 cv2.waitKey(0) cv2.destroyAllWindows() 图像平滑处理（滤波处理） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import numpy as np import cv2 import matplotlib.pyplot as plt plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False def cvshow(img): cv2.imshow(\u0026#34;image\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() image1 = cv2.imread(\u0026#34;./pictures/bad.png\u0026#34;,cv2.IMREAD_GRAYSCALE) # 均值滤波 cvshow1 = cv2.blur(image1,(3,3)) # 方框滤波 cvshow2=cv2.boxFilter(image1,-1,(3,3),normalize=True)# 效果同上均值滤波 cvshow3=cv2.boxFilter(image1,-1,(3,3),normalize=False)# 越界了 # 高斯滤波 cvshow4=cv2.GaussianBlur(image1,(3,3),1) # 中值滤波 cvshow5=cv2.medianBlur(image1,5) plt.figure(figsize=(15, 6)) plt.subplot(231),plt.imshow(cvshow1, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;均值滤波\u0026#39;) plt.subplot(232),plt.imshow(cvshow2, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;方框滤波_normalize=True\u0026#39;) plt.subplot(233),plt.imshow(cvshow3, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;方框滤波_normalize=False\u0026#39;) plt.subplot(234),plt.imshow(cvshow4, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;高斯滤波\u0026#39;) plt.subplot(235),plt.imshow(cvshow5, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;中值滤波\u0026#39;) plt.show(plt) 腐蚀与膨胀及其组合（开运算、闭运算、梯度运算、礼帽与黑帽） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import numpy as np import cv2 import matplotlib.pyplot as plt plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False def cvshow(img): cv2.imshow(\u0026#34;image\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() \u0026#34;\u0026#34;\u0026#34; 腐蚀与膨胀操作用于处理二值化的图像，由于大多数图片都是BGR三色的 下面写一个函数，将BGR图片处理为二值化图片 \u0026#34;\u0026#34;\u0026#34; def img_twonum(image1): image = cv2.cvtColor(image1, cv2.COLOR_BGR2GRAY)#确保图像是灰度图 ret,dst=cv2.threshold(image,127,255,cv2.THRESH_BINARY) return dst image1 = cv2.imread(r\u0026#34;./pictures/fushi.png\u0026#34;) image2 = img_twonum(image1) kernel = np.ones((5,5),np.uint8) #用 NumPy 库创建一个 5x5 的全1矩阵（内核/结构元素），数据类型为无符号8位整数（取值范围 0-255） erosion = cv2.erode(image2,kernel,iterations=1) # 腐蚀 # 最后的参数表示迭代次数 dilt = cv2.dilate(image2,kernel,iterations=1) # 膨胀 opening = cv2.morphologyEx(image2,cv2.MORPH_OPEN,kernel) # 开运算:先腐蚀再膨胀 close = cv2.morphologyEx(image2,cv2.MORPH_CLOSE,kernel) # 闭运算:先膨胀再腐蚀 gradient = cv2.morphologyEx(image2,cv2.MORPH_GRADIENT,kernel) # 梯度运算= 膨胀-腐蚀。得到边缘信息 tophat = cv2.morphologyEx(image2,cv2.MORPH_TOPHAT,kernel) # 礼帽= 原始输入-开运算 得到的是刺 blackhat = cv2.morphologyEx(image2,cv2.MORPH_BLACKHAT,kernel) # 黑帽 = 闭运算-原始输入 得到的是主体大概的轮廓 plt.figure(figsize=(15, 6)) plt.subplot(241),plt.imshow(erosion, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;腐蚀\u0026#39;) plt.subplot(242),plt.imshow(dilt, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;膨胀\u0026#39;) plt.subplot(243),plt.imshow(opening, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;开运算:先腐蚀再膨胀\u0026#39;) plt.subplot(244),plt.imshow(close, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;闭运算:先膨胀再腐蚀\u0026#39;) plt.subplot(245),plt.imshow(gradient, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;梯度运算= 膨胀-腐蚀\u0026#39;) plt.subplot(246),plt.imshow(tophat, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;礼帽=原始输入-开运算\u0026#39;) plt.subplot(247),plt.imshow(blackhat, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;黑帽=闭运算-原始输入\u0026#39;) plt.show(plt) 图像梯度计算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import numpy as np import cv2 import matplotlib.pyplot as plt plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False \u0026#34;\u0026#34;\u0026#34; 求梯度多用于灰度图片 但是不建议把dx,dx同时设置为1别计算，应该把dx、dy分开求出来，再进行融合 \u0026#34;\u0026#34;\u0026#34; def cvshow(img): cv2.imshow(\u0026#34;topic:zhenquanxu1\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() def juedui(*args): # 用于矩阵求绝对值 img = cv2.convertScaleAbs(*args) return img image1 = cv2.imread(\u0026#34;./pictures/pie.png\u0026#34;,cv2.IMREAD_GRAYSCALE) # sobel算子,分别计算x和y方向的一阶梯度，合并后显示边缘 sobelx = cv2.Sobel(image1,cv2.CV_64F,1,0,ksize=3) sobely = cv2.Sobel(image1,cv2.CV_64F,0,1,ksize=3) # scharr算子,类似Sobel，但对边缘更敏感 scharrx = cv2.Scharr(image1,cv2.CV_64F,1,0) scharry = cv2.Scharr(image1,cv2.CV_64F,0,1) # Laplacian算子,显示二阶导数边缘，通常比一阶算子对噪声更敏感，边缘更细,不能分开求 laplacian = cv2.Laplacian(image1,cv2.CV_64F,ksize=3) # 分别对每个梯度图像求绝对值 sobelx = cv2.convertScaleAbs(sobelx) sobely = cv2.convertScaleAbs(sobely) scharrx = cv2.convertScaleAbs(scharrx) scharry = cv2.convertScaleAbs(scharry) laplacian = cv2.convertScaleAbs(laplacian) # 求两个方向的梯度 sobelxy = cv2.addWeighted(sobelx,0.5,sobely,0.5,0) scharrxy = cv2.addWeighted(scharrx,0.5,scharry,0.5,0) plt.figure(figsize=(15, 2)) plt.subplot(131),plt.imshow(sobelxy, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;sobel算子\u0026#39;) plt.subplot(132),plt.imshow(scharrxy, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;scharr算子,类似Sobel，但对边缘更敏感\u0026#39;) plt.subplot(133),plt.imshow(laplacian, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;Laplacian算子,显示二阶导数边缘\u0026#39;) plt.show() canny边缘检测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import numpy as np import cv2 import matplotlib.pyplot as plt image1 = cv2.imread(\u0026#34;./pictures/bad.png\u0026#34;,cv2.IMREAD_GRAYSCALE) v1= cv2.Canny(image1,10,150) # 分别指的是maxval,minval v2= cv2.Canny(image1,30,150) v3= cv2.Canny(image1,50,150) v4= cv2.Canny(image1,50,51) v5= cv2.Canny(image1,50,100) v6= cv2.Canny(image1,50,200) v7= cv2.Canny(image1,145,150) v8= cv2.Canny(image1,200,201) plt.figure(figsize=(15, 6)) plt.subplot(241),plt.imshow(v1, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;canny_10*150\u0026#39;) plt.subplot(242),plt.imshow(v2, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;canny_30*150\u0026#39;) plt.subplot(243),plt.imshow(v3, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;canny_50*150\u0026#39;) plt.subplot(244),plt.imshow(v4, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;canny_50*51\u0026#39;) plt.subplot(245),plt.imshow(v5, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;canny_50*100\u0026#39;) plt.subplot(246),plt.imshow(v6, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;canny_50*200\u0026#39;) plt.subplot(247),plt.imshow(v7, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;canny_145*150\u0026#39;) plt.subplot(248),plt.imshow(v8, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;canny_200*201\u0026#39;) plt.show() 图像金字塔 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import cv2 import matplotlib.pyplot as plt plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False def cvshow(img): cv2.imshow(\u0026#34;image\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() # 高斯金字塔 image1 = cv2.imread(r\u0026#34;./pictures/AM.png\u0026#34;,cv2.IMREAD_GRAYSCALE) up1 =cv2.pyrUp(image1) #图像变大 up2 =cv2.pyrDown(image1) #图像变大小 # 拉普拉斯金字塔 def laplasi(): image1 = cv2.imread(r\u0026#34;./pictures/AM.png\u0026#34;, cv2.IMREAD_GRAYSCALE) down = cv2.pyrDown(image1) down_up = cv2.pyrUp(down) image = image1-down_up # 这个拉普拉斯金字塔只迭代了1次 image1 = cv2.imread(r\u0026#34;./pictures/AM.png\u0026#34;, cv2.IMREAD_GRAYSCALE) for i in range(0,1): # 这里可以设置迭代次数 down = cv2.pyrDown(image1) down_up = cv2.pyrUp(down) image1 = image1-down_up plt.subplot(131),plt.imshow(up1,cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;高斯金字塔_up\u0026#39;) plt.subplot(132),plt.imshow(up2,cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;高斯金字塔_down\u0026#39;) plt.subplot(133),plt.imshow(image1,cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;拉普拉斯金字塔\u0026#39;) plt.show() 图像轮廓 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import numpy as np import cv2 import matplotlib.pyplot as plt plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False def cvshow(img): cv2.imshow(\u0026#34;image\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() image1=cv2.imread(r\u0026#34;./pictures/cars.jpg\u0026#34;) gray = cv2.cvtColor(image1,cv2.COLOR_BGR2GRAY) a,image1_1 = cv2.threshold(gray,127,255,cv2.THRESH_BINARY) binary,contours,hierarchy = cv2.findContours(image1_1,cv2.RETR_TREE,cv2.CHAIN_APPROX_NONE) # 绘制轮廓 drawimage = image1.copy() # ###注意不要对原图进行操作 res = cv2.drawContours(drawimage,contours,-1,(0,0,255),2) res_rgb = cv2.cvtColor(res, cv2.COLOR_BGR2RGB) # 关键步骤：BGR转RGB plt.subplot(),plt.imshow(res_rgb),plt.title(\u0026#39;绘制轮廓\u0026#39;) plt.show() # 进一步可以调用轮廓的各种特征 轮廓近似 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import numpy as np import cv2 from numpy.ma import hstack from numpy.ma import vstack def cvshow(img): cv2.imshow(\u0026#34;image\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() import cv2 from numpy.ma import hstack from numpy.ma import vstack def cvshow(img): cv2.imshow(\u0026#34;image\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() image1=cv2.imread(r\u0026#34;./pictures/lunkuo.png\u0026#34;) # 图像预处理 gray1 = cv2.cvtColor(image1,cv2.COLOR_BGR2GRAY) a,image2 = cv2.threshold(gray1,127,255,cv2.THRESH_BINARY) binary,contours,hierarchy = cv2.findContours(image2,cv2.RETR_TREE,cv2.CHAIN_APPROX_NONE) cont = contours[0] #检测到的第一个轮廓 epsilon = 0.1*cv2.arcLength(cont,True) approx = cv2.approxPolyDP(cont,epsilon,True) image3 = image1.copy() res = cv2.drawContours(image3,[approx],-1,(0,0,255),2) # 外接矩形 x,y,w,h = cv2.boundingRect(cont) image4 = image1.copy() image4 = cv2.rectangle(image4,(x,y),(x+w,y+h),(0,0,255),2) # 外接圆 (x,y),radius = cv2.minEnclosingCircle(cont) center = (int(x),int(y)) radius= int(radius) image5 = cv2.circle(image1,center,radius,(0,0,255),2) image = hstack((res,image4,image5)) cvshow(image) 图像匹配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import numpy as np import cv2 from cv2 import TM_CCORR, TM_CCORR_NORMED, TM_SQDIFF, TM_SQDIFF_NORMED from numpy.ma import hstack from numpy.ma import vstack def cvshow(img): cv2.imshow(\u0026#34;image\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() image1=cv2.imread(r\u0026#34;./pictures/GEM.png\u0026#34;,0) image2=cv2.imread(r\u0026#34;./pictures/GEM_face.png\u0026#34;,0) image3 = image1.copy() h,w = image2.shape[:2] \u0026#34;\u0026#34;\u0026#34; cv2.IMREAD_COLOR (1)：加载彩色图像，忽略透明度。 cv2.IMREAD_GRAYSCALE (0)：以灰度模式加载图像。 cv2.IMREAD_UNCHANGED (-1)：加载图像包含alpha通道。 \u0026#34;\u0026#34;\u0026#34; res = cv2.matchTemplate(image1,image2,TM_CCORR_NORMED) a,b,c,d = cv2.minMaxLoc(res) youxia = (d[0]+w,d[1]+h) image = cv2.rectangle(image3,d,youxia,(0,255,0),2) cvshow(image) 直方图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 %matplotlib inline import cv2 import matplotlib.pyplot as plt # 设置中文字体 plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False image1 = cv2.imread(\u0026#34;./pictures/GEM.png\u0026#34;) image1_gray = cv2.cvtColor(image1, cv2.COLOR_BGR2GRAY) # 计算灰度直方图（OpenCV方式） hist = cv2.calcHist([image1_gray], [0], None, [256], [0, 256]) # 将直方图数据转换为可绘制的形式 plt.figure(figsize=(10, 2)) plt.plot(hist, color=\u0026#39;blue\u0026#39;) # 用曲线绘制直方图 # 或使用柱状图： # plt.bar(range(256), hist.ravel(), color=\u0026#39;gray\u0026#39;, width=1.0) # 设置图表属性 plt.title(\u0026#34;灰度直方图（基于cv2.calcHist）\u0026#34;),plt.xlabel(\u0026#34;像素值 (0-255)\u0026#34;),plt.ylabel(\u0026#34;频次\u0026#34;),plt.xlim([0, 255]) # 限制X轴范围 plt.grid(alpha=1) # 表示网格线是半透明的（30% 不透明） plt.show() # 分别统计这张彩色图的b、g、r plt.figure(figsize=(10, 2)) color = (\u0026#39;b\u0026#39;,\u0026#39;g\u0026#39;,\u0026#39;r\u0026#39;) # 通过for循环，将不同颜色进行统计，绘制在三张图上，最后将三张图统一展示。 for i, col in enumerate(color): # enumerate可以同时得到索引和数据 hist = cv2.calcHist([image1], [i], None, [256], [0, 256]) plt.plot(hist, color=col) plt.xlim([0, 256]) plt.show() musk的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 %matplotlib inline import numpy as np import cv2 import matplotlib.pyplot as plt # 设置中文字体 plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False image= cv2.imread(\u0026#39;./pictures/GEM.png\u0026#39;, cv2.IMREAD_GRAYSCALE) musk = np.zeros(image.shape[:2],np.uint8) musk[100:300,100:400] = 255 # 把保存的东西设置为255 hist = cv2.calcHist([image],[0],musk,[256],[0,256]) plt.figure(figsize=(10, 2)) plt.plot(hist) plt.xlim([0,256]) plt.show() 均衡化与自适应均衡化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import numpy as np import cv2 import matplotlib.pyplot as plt # 设置中文字体 plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False image= cv2.imread(\u0026#39;./pictures/GEM.png\u0026#39;, cv2.IMREAD_GRAYSCALE) musk = np.zeros(image.shape[:2],np.uint8) musk[100:300,100:400] = 255 hist = cv2.calcHist([image],[0],musk,[256],[0,256]) a = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8)) res_clahe = a.apply(image) equ = cv2.equalizeHist(image) plt.figure(figsize=(8, 2)) plt.subplot(122),plt.imshow(res_clahe,cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#34;自适应均衡化\u0026#34;) plt.subplot(121),plt.imshow(equ,cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#34;均衡化\u0026#34;) plt.show() 低通与高通滤波 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import cv2 import numpy as np import matplotlib.pyplot as plt # 设置中文字体 plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False image = cv2.imread(\u0026#39;./pictures/GEM.png\u0026#39;, cv2.IMREAD_GRAYSCALE)#读取图像 image_float32 = np.float32(image) # 转化格式为np.float32 a = cv2.dft(image_float32, flags=cv2.DFT_COMPLEX_OUTPUT) # 进行频域变化 a_shift = np.fft.fftshift(a) # 将低频值放到中心处 img2 = 20*np.log(cv2.magnitude(a_shift[:,:,0], a_shift[:,:,1])) # 转化为灰度图可以展示的图像 rows, cols = image.shape crow, ccol = int(rows / 2), int(cols / 2) # 低通滤波器(会使得图像变模糊) musk = np.zeros((rows, cols,2),np.uint8) musk[crow-30:crow+30, ccol-30:ccol+30] = 1 # IDFT fshift = a_shift*musk f_shift = np.fft.ifftshift(fshift) # 还原这一步操作：“将低频值放到中心处” img = cv2.idft(f_shift) img = cv2.magnitude(img[:,:,0], img[:,:,1]) # 把实部与虚部分开 # 高通滤波器 musk2 = np.ones((rows, cols,2),np.uint8) musk2[crow-30:crow+30, ccol-30:ccol+30] = 0 fshift2 = a_shift*musk2 f_shift2 = np.fft.ifftshift(fshift2) img2 = cv2.idft(f_shift2) img2 = cv2.magnitude(img2[:,:,0], img2[:,:,1]) plt.subplot(221),plt.imshow(img2, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#34;频域图\u0026#34;) plt.subplot(222),plt.imshow(image, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#34;原始图像\u0026#34;) plt.subplot(223),plt.imshow(img, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#34;低通滤波器\u0026#34;) plt.subplot(224),plt.imshow(img2, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#34;高通滤波器\u0026#34;) plt.show() 角点检测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 %matplotlib inline import cv2 import numpy as np import matplotlib.pyplot as plt # 设置中文字体 plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False def show(img): cv2.imshow(\u0026#34;topic:zhenquanxu1\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() image = cv2.imread(\u0026#34;./pictures/guojixiangqi_qipan.jpg\u0026#34;) image_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) image_gray_32 = np.float32(image_gray) # ！！！注意要求把灰度图转化为np.float32格式的，这很重要！！！ dst = cv2.cornerHarris(image_gray_32, 2, 3, 0.04) # 固定用法 image[dst \u0026gt; 0.01 * dst.max()] = [0, 0, 255] # 固定用法，用于筛选出响应值大于最大响应值 1% 的像素点，这些像素点被认为是角点 plt.imshow(image),plt.title(\u0026#34;角点检测\u0026#34;) plt.show() .SIFT函数检测特征点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 %matplotlib inline import cv2 import numpy as np import matplotlib.pyplot as plt plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False def show(img): cv2.imshow(\u0026#34;topic:zhenquanxu1\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() # 图像读取与预处理 image = cv2.imread(\u0026#34;./pictures/GEM.png\u0026#34;) image_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) # 得到特征点（key points） sift = cv2.xfeatures2d.SIFT_create() kp = sift.detect(image_gray, None) # 传入的是灰度图 # 绘制特征点 image = cv2.drawKeypoints(image_gray, kp, image, color=(0, 255, 0)) # 输出图片 plt.subplot(),plt.imshow(image, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#34;SIFT特征点\u0026#34;),plt.show() # 计算特征 kp,des = sift.compute(image_gray, kp) print(np.array(kp).shape) # 特征点的个数 print(des.shape) # 每一个特征点都是一个128维的向量 print(des[0]) # 每一个特征点都是一个128维的向量，可以数一下是128维 Brute-Force蛮力匹配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 %matplotlib inline import numpy as np import matplotlib.pyplot as plt import cv2 plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False def show(img): cv2.imshow(\u0026#34;topic:zhenquanxu1\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() image1 = cv2.imread(\u0026#34;./pictures/GEM_face.png\u0026#34;) image2 = cv2.imread(\u0026#34;./pictures/GEM.png\u0026#34;) sift = cv2.xfeatures2d.SIFT_create() kp1, des1 = sift.detectAndCompute(image1, None) # 找到特征点与特征向量 kp2, des2 = sift.detectAndCompute(image2, None) # 找到特征点与特征向量 bf1 = cv2.BFMatcher(crossCheck=True) # 1对1的匹配 matches = bf1.match(des1, des2) matches = sorted(matches, key=lambda x: x.distance) image3 = cv2.drawMatches(image1, kp1, image2, kp2, matches[:10], None, flags=2) # k对最佳匹配 bf2 = cv2.BFMatcher() matches2 = bf2.knnMatch(des1,des2,2) good = [] for m, n in matches2: if m.distance \u0026lt; 0.75*n.distance: good.append(m) image4 = cv2.drawMatches(image1, kp1, image2, kp2, good, None, flags=2) # 展示图片 image3_rgb = image3[:, :, ::-1] # 把BGR图片转化为RGB图片 image4_rgb = image4[:, :, ::-1] # 把BGR图片转化为RGB图片 plt.subplot(221),plt.imshow(image3_rgb),plt.title(\u0026#34;1对1的匹配\u0026#34;) plt.subplot(222),plt.imshow(image4_rgb),plt.title(\u0026#34;k对最佳匹配\u0026#34;) plt.show() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 %matplotlib inline import cv2 import numpy as np import matplotlib.pyplot as plt plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False imageA = cv2.imread(\u0026#34;./pictures/p1.png\u0026#34;) imageB = cv2.imread(\u0026#34;./pictures/p2.png\u0026#34;) gray1 = cv2.cvtColor(imageA, cv2.COLOR_BGR2GRAY) gray2 = cv2.cvtColor(imageB, cv2.COLOR_BGR2GRAY) sift = cv2.xfeatures2d.SIFT_create() kpsA,dpA = sift.detectAndCompute(gray1, None) kpsB,dpB = sift.detectAndCompute(gray2, None) bf = cv2.BFMatcher() matches = bf.knnMatch(dpA,dpB,2) good = [] for m in matches: if len(m) == 2 and m[0].distance \u0026lt; m[1].distance * 0.75: good.append((m[0].queryIdx,m[0].trainIdx)) kps1 = np.float32([kp.pt for kp in kpsA]) kps2 = np.float32([kp.pt for kp in kpsB]) kps1 = np.float32([kps1[a[0]] for a in good]) kps2 = np.float32([kps2[a[1]] for a in good]) M,status = cv2.findHomography(kps2,kps1,cv2.RANSAC,4.0) result = cv2.warpPerspective(imageB, M, (imageA.shape[1]+imageB.shape[1],imageA.shape[0])) result[0:imageA.shape[0],0:imageA.shape[1]] = imageA # 计算变换后的图像B的边界 h, w = imageB.shape[:2] corners = np.array([[0, 0], [0, h-1], [w-1, h-1], [w-1, 0]], dtype=np.float32) warped_corners = cv2.perspectiveTransform(corners.reshape(1, -1, 2), M).reshape(-1, 2) # 计算输出画布的最小包围矩形 all_corners = np.concatenate((warped_corners, np.array([[0,0], [imageA.shape[1], imageA.shape[0]]])), axis=0) x_min, y_min = np.floor(np.min(all_corners, axis=0)).astype(int) x_max, y_max = np.ceil(np.max(all_corners, axis=0)).astype(int) # 计算平移变换矩阵 offset_x = -x_min offset_y = -y_min translation_matrix = np.array([[1, 0, offset_x], [0, 1, offset_y], [0, 0, 1]]) # 调整单应性矩阵并执行透视变换 adjusted_homography = translation_matrix.dot(M) result = cv2.warpPerspective(imageB, adjusted_homography, (x_max - x_min, y_max - y_min)) # 创建新的拼接画布 result[offset_y:offset_y+imageA.shape[0], offset_x:offset_x+imageA.shape[1]] = imageA # 自动裁剪黑边 gray = cv2.cvtColor(result, cv2.COLOR_BGR2GRAY) _, thresh = cv2.threshold(gray, 1, 255, cv2.THRESH_BINARY) _,contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) x,y,w,h = cv2.boundingRect(contours[0]) final = result[y:y+h, x:x+w] # 展示图片 final_rgb = final[:, :, ::-1] # 把BGR图片转化为RGB图片 imageA_rgb = imageA[:, :, ::-1]# 把BGR图片转化为RGB图片 imageB_rgb = imageB[:, :, ::-1]# 把BGR图片转化为RGB图片 plt.subplot(131),plt.imshow(imageA_rgb),plt.title(\u0026#34;左边的图片\u0026#34;) plt.subplot(132),plt.imshow(imageB_rgb),plt.title(\u0026#34;右边的图片\u0026#34;) plt.subplot(133),plt.imshow(final_rgb),plt.title(\u0026#34;拼接后的图片\u0026#34;) plt.show() ","date":"2025-04-13T14:47:46+08:00","permalink":"http://localhost:5377/p/opencv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"opencv学习笔记"}]
[{"content":"图像读取 1 2 3 4 5 6 7 8 9 10 11 12 # 导包 import cv2 import numpy as np from numpy.ma import hstack# 用于横向拼接图片 from numpy.ma import vstack# 用于纵向拼接图片 def cv_show(img): cv2.imshow(\u0026#34;topic:zhenquanxu1\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() image1 = cv2.imread(\u0026#34;./pictures/plane.jpg\u0026#34;) image2 = cv2.imread(\u0026#34;./pictures/plane.jpg\u0026#34;,cv2.IMREAD_GRAYSCALE) cv_show(image2) 视频读取 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import cv2 import numpy as np vc = cv2.VideoCapture(r\u0026#34;C:\\Users\\zhenq\\Videos\\03.mp4\u0026#34;) # 图像的读取 # 异常处理 if vc.isOpened(): oepn,frame = vc.read() else: open = False # 使用循环体对每一帧图像进行读取 while open: ret,frame=vc.read() # frame位置是帧，如果视频没有了，frame变为None,视频退出播放 if frame is None: break # ret 表示程序能否读取视频 if ret == True: cv2.imshow(\u0026#34;这是一个测试\u0026#34;,cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY))# 对每一帧进行灰度处理 if cv2.waitKey(10)\u0026amp;0xFF==27: # 程序等待10毫秒，在这个时间内检测用户键盘输入，esc的ASCII码是27.检测后进入下一次的while循环 break vc.release() cv2.destroyAllWindows() 图像的灰度处理、截取、颜色通道的提取、调整大小与融合、阈值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import cv2 import numpy as np def cv_show(img): cv2.imshow(\u0026#34;topic:zhenquanxu1\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() # 图像的灰度处理方法一：在imread中添加相关参数，这钟方法不建议使用，此处不再写 # 图像的灰度处理方法二：将传入的图像进行二次处理,这种方法可以分别得到原图和灰度图，方便展示 image = cv2.imread(r\u0026#34;./pictures/GEM.png\u0026#34;) image_gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY) \u0026#34;\u0026#34;\u0026#34; 截取图像，在使用imread后，得到的是一个矩阵（或者说是一个list[]列表），可以使用切片的方法从里面得到部分数据 对于BGR彩色图，这个list是一个\u0026#34;[[[B,G,R]]]\u0026#34;,比如下面这个3*3的图片 [[[ 62 62 62] [ 56 56 56] [ 33 33 33]] [[126 126 126] [ 58 58 58] [ 57 57 57]] [[ 61 61 61] [ 94 94 94] [217 217 217]]] 可以横向进行表示，更容易理解： [[[ 62 62 62],[ 56 56 56],[ 33 33 33]] [[126 126 126],[ 58 58 58],[ 57 57 57]] [[ 61 61 61],[ 94 94 94],[217 217 217]]] list[0:2]可以把0行、1行拿出来，也就是列表中的第一行和第二行 list[0:2][0:1]可以把列表中前两行、第一列列拿出来。当然了list[0:2,0:1]和list[0:2][0:1]是一样的。 进一步的说[0:2]是图片的高，[0:1]是图片的宽。在cv2中图像的坐标原点在左上角，水平方向是w轴，竖直方向是h，要理解图像和矩阵之间的转换关系。 每一个像素点由三个数字表示；对于灰度图，一个数字就可以表示一个像素点。 \u0026#34;\u0026#34;\u0026#34; # 在理解了图像和矩阵或者说列表之间的关系，下面的就很好理解了。对列表进行三次切片可以得到相应的BGR颜色值。 #只保留R.注意在cv2中顺序是BGR，不是RGB image[:,:,0]=0 image[:,:,1]=0 \u0026#34;\u0026#34;\u0026#34; cv2.resize(image1,(100,100)) #调整大小为100*100 cv2.resize(image1,(0,0),fx=2,fy=2) #图像沿着x方向y方向进行拉伸 cv2.addWeighted(image,0.5,image1,0.5,0) #res=A*image+B*image1+C,在这里A,B,C分别是0.5，0.5，0 \u0026#34;\u0026#34;\u0026#34; 边界填充 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import cv2 import numpy as np import matplotlib.pyplot as plt plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False def cvshow(image): cv2.imshow(\u0026#34;this is a top\u0026#34;,image) cv2.waitKey(0) cv2.destroyAllWindows() image1 = cv2.imread(r\u0026#34;./pictures/03.png\u0026#34;)# 图片大小(746, 1374, 3) # 为了进行边界填充，首先将图片进行切割。 image2 = image1[0:512,0:512] # 边界填充 top,bottom,left,right =(100,100,100,100) # 1.replicate法填充 replicate = cv2.copyMakeBorder(image2,top,bottom,left,right,borderType=cv2.BORDER_REPLICATE) # 2.reflect 法填充 reflect = cv2.copyMakeBorder(image2,top,bottom,left,right,borderType=cv2.BORDER_REFLECT) # 3.reflect101 法填充 reflect101 = cv2.copyMakeBorder(image2,top,bottom,left,right,borderType=cv2.BORDER_REFLECT_101) # 4.wrap法填充 wrap = cv2.copyMakeBorder(image2,top,bottom,left,right,borderType=cv2.BORDER_WRAP) # 5.constant法填充 constant = cv2.copyMakeBorder(image2,top,bottom,left,right,borderType=cv2.BORDER_CONSTANT,value=0) #图片展示，其中\u0026#34;231\u0026#34;，2表示总行数；3表示总列数；1表示这六个位置中的第一个位置。 plt.figure(figsize=(10, 6)) plt.subplot(231),plt.imshow(replicate),plt.title(\u0026#39;replicate法填充\u0026#39;) plt.subplot(232),plt.imshow(reflect),plt.title(\u0026#39;reflect法填充\u0026#39;) plt.subplot(233),plt.imshow(reflect101),plt.title(\u0026#39;reflect101法填充\u0026#39;) plt.subplot(234),plt.imshow(wrap),plt.title(\u0026#39;wrap法填充\u0026#39;) plt.subplot(235),plt.imshow(constant),plt.title(\u0026#39;constant法填充\u0026#39;) plt.show(plt) 数值计算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import numpy as np import cv2 import matplotlib.pyplot as plt def cvshow(img): cv2.imshow(\u0026#34;image\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() image1 = cv2.imread(r\u0026#34;./pictures/opencv_logo.jpg\u0026#34;) image2 = cv2.imread(r\u0026#34;./pictures/plane.jpg\u0026#34;) image = image2[0:250,0:250] # 使image与image1大小相同，以保证矩阵能正常进行运算 def fun1(): image = image2[0:250,0:250] cv2.imshow(\u0026#34;6\u0026#34;,image+100) # 将矩阵中的每一个数字加100 cv2.imshow(\u0026#34;6\u0026#34;,image+image1) # 大小相同的两个矩阵相加，超过255的部分取余数 cv2.add(image1,image) #大小相同的两个矩阵相加，超过255的统一取为255 cv2.waitKey(0) cv2.destroyAllWindows() 图像平滑处理（滤波处理） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import numpy as np import cv2 import matplotlib.pyplot as plt plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False def cvshow(img): cv2.imshow(\u0026#34;image\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() image1 = cv2.imread(\u0026#34;./pictures/bad.png\u0026#34;,cv2.IMREAD_GRAYSCALE) # 均值滤波 cvshow1 = cv2.blur(image1,(3,3)) # 方框滤波 cvshow2=cv2.boxFilter(image1,-1,(3,3),normalize=True)# 效果同上均值滤波 cvshow3=cv2.boxFilter(image1,-1,(3,3),normalize=False)# 越界了 # 高斯滤波 cvshow4=cv2.GaussianBlur(image1,(3,3),1) # 中值滤波 cvshow5=cv2.medianBlur(image1,5) plt.figure(figsize=(15, 6)) plt.subplot(231),plt.imshow(cvshow1, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;均值滤波\u0026#39;) plt.subplot(232),plt.imshow(cvshow2, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;方框滤波_normalize=True\u0026#39;) plt.subplot(233),plt.imshow(cvshow3, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;方框滤波_normalize=False\u0026#39;) plt.subplot(234),plt.imshow(cvshow4, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;高斯滤波\u0026#39;) plt.subplot(235),plt.imshow(cvshow5, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;中值滤波\u0026#39;) plt.show(plt) 腐蚀与膨胀及其组合（开运算、闭运算、梯度运算、礼帽与黑帽） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import numpy as np import cv2 import matplotlib.pyplot as plt plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False def cvshow(img): cv2.imshow(\u0026#34;image\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() \u0026#34;\u0026#34;\u0026#34; 腐蚀与膨胀操作用于处理二值化的图像，由于大多数图片都是BGR三色的 下面写一个函数，将BGR图片处理为二值化图片 \u0026#34;\u0026#34;\u0026#34; def img_twonum(image1): image = cv2.cvtColor(image1, cv2.COLOR_BGR2GRAY)#确保图像是灰度图 ret,dst=cv2.threshold(image,127,255,cv2.THRESH_BINARY) return dst image1 = cv2.imread(r\u0026#34;./pictures/fushi.png\u0026#34;) image2 = img_twonum(image1) kernel = np.ones((5,5),np.uint8) #用 NumPy 库创建一个 5x5 的全1矩阵（内核/结构元素），数据类型为无符号8位整数（取值范围 0-255） erosion = cv2.erode(image2,kernel,iterations=1) # 腐蚀 # 最后的参数表示迭代次数 dilt = cv2.dilate(image2,kernel,iterations=1) # 膨胀 opening = cv2.morphologyEx(image2,cv2.MORPH_OPEN,kernel) # 开运算:先腐蚀再膨胀 close = cv2.morphologyEx(image2,cv2.MORPH_CLOSE,kernel) # 闭运算:先膨胀再腐蚀 gradient = cv2.morphologyEx(image2,cv2.MORPH_GRADIENT,kernel) # 梯度运算= 膨胀-腐蚀。得到边缘信息 tophat = cv2.morphologyEx(image2,cv2.MORPH_TOPHAT,kernel) # 礼帽= 原始输入-开运算 得到的是刺 blackhat = cv2.morphologyEx(image2,cv2.MORPH_BLACKHAT,kernel) # 黑帽 = 闭运算-原始输入 得到的是主体大概的轮廓 plt.figure(figsize=(15, 6)) plt.subplot(241),plt.imshow(erosion, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;腐蚀\u0026#39;) plt.subplot(242),plt.imshow(dilt, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;膨胀\u0026#39;) plt.subplot(243),plt.imshow(opening, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;开运算:先腐蚀再膨胀\u0026#39;) plt.subplot(244),plt.imshow(close, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;闭运算:先膨胀再腐蚀\u0026#39;) plt.subplot(245),plt.imshow(gradient, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;梯度运算= 膨胀-腐蚀\u0026#39;) plt.subplot(246),plt.imshow(tophat, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;礼帽=原始输入-开运算\u0026#39;) plt.subplot(247),plt.imshow(blackhat, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;黑帽=闭运算-原始输入\u0026#39;) plt.show(plt) 图像梯度计算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import numpy as np import cv2 import matplotlib.pyplot as plt plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False \u0026#34;\u0026#34;\u0026#34; 求梯度多用于灰度图片 但是不建议把dx,dx同时设置为1别计算，应该把dx、dy分开求出来，再进行融合 \u0026#34;\u0026#34;\u0026#34; def cvshow(img): cv2.imshow(\u0026#34;topic:zhenquanxu1\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() def juedui(*args): # 用于矩阵求绝对值 img = cv2.convertScaleAbs(*args) return img image1 = cv2.imread(\u0026#34;./pictures/pie.png\u0026#34;,cv2.IMREAD_GRAYSCALE) # sobel算子,分别计算x和y方向的一阶梯度，合并后显示边缘 sobelx = cv2.Sobel(image1,cv2.CV_64F,1,0,ksize=3) sobely = cv2.Sobel(image1,cv2.CV_64F,0,1,ksize=3) # scharr算子,类似Sobel，但对边缘更敏感 scharrx = cv2.Scharr(image1,cv2.CV_64F,1,0) scharry = cv2.Scharr(image1,cv2.CV_64F,0,1) # Laplacian算子,显示二阶导数边缘，通常比一阶算子对噪声更敏感，边缘更细,不能分开求 laplacian = cv2.Laplacian(image1,cv2.CV_64F,ksize=3) # 分别对每个梯度图像求绝对值 sobelx = cv2.convertScaleAbs(sobelx) sobely = cv2.convertScaleAbs(sobely) scharrx = cv2.convertScaleAbs(scharrx) scharry = cv2.convertScaleAbs(scharry) laplacian = cv2.convertScaleAbs(laplacian) # 求两个方向的梯度 sobelxy = cv2.addWeighted(sobelx,0.5,sobely,0.5,0) scharrxy = cv2.addWeighted(scharrx,0.5,scharry,0.5,0) plt.figure(figsize=(15, 2)) plt.subplot(131),plt.imshow(sobelxy, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;sobel算子\u0026#39;) plt.subplot(132),plt.imshow(scharrxy, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;scharr算子,类似Sobel，但对边缘更敏感\u0026#39;) plt.subplot(133),plt.imshow(laplacian, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;Laplacian算子,显示二阶导数边缘\u0026#39;) plt.show() canny边缘检测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import numpy as np import cv2 import matplotlib.pyplot as plt image1 = cv2.imread(\u0026#34;./pictures/bad.png\u0026#34;,cv2.IMREAD_GRAYSCALE) v1= cv2.Canny(image1,10,150) # 分别指的是maxval,minval v2= cv2.Canny(image1,30,150) v3= cv2.Canny(image1,50,150) v4= cv2.Canny(image1,50,51) v5= cv2.Canny(image1,50,100) v6= cv2.Canny(image1,50,200) v7= cv2.Canny(image1,145,150) v8= cv2.Canny(image1,200,201) plt.figure(figsize=(15, 6)) plt.subplot(241),plt.imshow(v1, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;canny_10*150\u0026#39;) plt.subplot(242),plt.imshow(v2, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;canny_30*150\u0026#39;) plt.subplot(243),plt.imshow(v3, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;canny_50*150\u0026#39;) plt.subplot(244),plt.imshow(v4, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;canny_50*51\u0026#39;) plt.subplot(245),plt.imshow(v5, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;canny_50*100\u0026#39;) plt.subplot(246),plt.imshow(v6, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;canny_50*200\u0026#39;) plt.subplot(247),plt.imshow(v7, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;canny_145*150\u0026#39;) plt.subplot(248),plt.imshow(v8, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;canny_200*201\u0026#39;) plt.show() 图像金字塔 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import cv2 import matplotlib.pyplot as plt plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False def cvshow(img): cv2.imshow(\u0026#34;image\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() # 高斯金字塔 image1 = cv2.imread(r\u0026#34;./pictures/AM.png\u0026#34;,cv2.IMREAD_GRAYSCALE) up1 =cv2.pyrUp(image1) #图像变大 up2 =cv2.pyrDown(image1) #图像变大小 # 拉普拉斯金字塔 def laplasi(): image1 = cv2.imread(r\u0026#34;./pictures/AM.png\u0026#34;, cv2.IMREAD_GRAYSCALE) down = cv2.pyrDown(image1) down_up = cv2.pyrUp(down) image = image1-down_up # 这个拉普拉斯金字塔只迭代了1次 image1 = cv2.imread(r\u0026#34;./pictures/AM.png\u0026#34;, cv2.IMREAD_GRAYSCALE) for i in range(0,1): # 这里可以设置迭代次数 down = cv2.pyrDown(image1) down_up = cv2.pyrUp(down) image1 = image1-down_up plt.subplot(131),plt.imshow(up1,cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;高斯金字塔_up\u0026#39;) plt.subplot(132),plt.imshow(up2,cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;高斯金字塔_down\u0026#39;) plt.subplot(133),plt.imshow(image1,cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#39;拉普拉斯金字塔\u0026#39;) plt.show() 图像轮廓 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import numpy as np import cv2 import matplotlib.pyplot as plt plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False def cvshow(img): cv2.imshow(\u0026#34;image\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() image1=cv2.imread(r\u0026#34;./pictures/cars.jpg\u0026#34;) gray = cv2.cvtColor(image1,cv2.COLOR_BGR2GRAY) a,image1_1 = cv2.threshold(gray,127,255,cv2.THRESH_BINARY) binary,contours,hierarchy = cv2.findContours(image1_1,cv2.RETR_TREE,cv2.CHAIN_APPROX_NONE) # 绘制轮廓 drawimage = image1.copy() # ###注意不要对原图进行操作 res = cv2.drawContours(drawimage,contours,-1,(0,0,255),2) res_rgb = cv2.cvtColor(res, cv2.COLOR_BGR2RGB) # 关键步骤：BGR转RGB plt.subplot(),plt.imshow(res_rgb),plt.title(\u0026#39;绘制轮廓\u0026#39;) plt.show() # 进一步可以调用轮廓的各种特征 轮廓近似 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import numpy as np import cv2 from numpy.ma import hstack from numpy.ma import vstack def cvshow(img): cv2.imshow(\u0026#34;image\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() import cv2 from numpy.ma import hstack from numpy.ma import vstack def cvshow(img): cv2.imshow(\u0026#34;image\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() image1=cv2.imread(r\u0026#34;./pictures/lunkuo.png\u0026#34;) # 图像预处理 gray1 = cv2.cvtColor(image1,cv2.COLOR_BGR2GRAY) a,image2 = cv2.threshold(gray1,127,255,cv2.THRESH_BINARY) binary,contours,hierarchy = cv2.findContours(image2,cv2.RETR_TREE,cv2.CHAIN_APPROX_NONE) cont = contours[0] #检测到的第一个轮廓 epsilon = 0.1*cv2.arcLength(cont,True) approx = cv2.approxPolyDP(cont,epsilon,True) image3 = image1.copy() res = cv2.drawContours(image3,[approx],-1,(0,0,255),2) # 外接矩形 x,y,w,h = cv2.boundingRect(cont) image4 = image1.copy() image4 = cv2.rectangle(image4,(x,y),(x+w,y+h),(0,0,255),2) # 外接圆 (x,y),radius = cv2.minEnclosingCircle(cont) center = (int(x),int(y)) radius= int(radius) image5 = cv2.circle(image1,center,radius,(0,0,255),2) image = hstack((res,image4,image5)) cvshow(image) 图像匹配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import numpy as np import cv2 from cv2 import TM_CCORR, TM_CCORR_NORMED, TM_SQDIFF, TM_SQDIFF_NORMED from numpy.ma import hstack from numpy.ma import vstack def cvshow(img): cv2.imshow(\u0026#34;image\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() image1=cv2.imread(r\u0026#34;./pictures/GEM.png\u0026#34;,0) image2=cv2.imread(r\u0026#34;./pictures/GEM_face.png\u0026#34;,0) image3 = image1.copy() h,w = image2.shape[:2] \u0026#34;\u0026#34;\u0026#34; cv2.IMREAD_COLOR (1)：加载彩色图像，忽略透明度。 cv2.IMREAD_GRAYSCALE (0)：以灰度模式加载图像。 cv2.IMREAD_UNCHANGED (-1)：加载图像包含alpha通道。 \u0026#34;\u0026#34;\u0026#34; res = cv2.matchTemplate(image1,image2,TM_CCORR_NORMED) a,b,c,d = cv2.minMaxLoc(res) youxia = (d[0]+w,d[1]+h) image = cv2.rectangle(image3,d,youxia,(0,255,0),2) cvshow(image) 直方图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 %matplotlib inline import cv2 import matplotlib.pyplot as plt # 设置中文字体 plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False image1 = cv2.imread(\u0026#34;./pictures/GEM.png\u0026#34;) image1_gray = cv2.cvtColor(image1, cv2.COLOR_BGR2GRAY) # 计算灰度直方图（OpenCV方式） hist = cv2.calcHist([image1_gray], [0], None, [256], [0, 256]) # 将直方图数据转换为可绘制的形式 plt.figure(figsize=(10, 2)) plt.plot(hist, color=\u0026#39;blue\u0026#39;) # 用曲线绘制直方图 # 或使用柱状图： # plt.bar(range(256), hist.ravel(), color=\u0026#39;gray\u0026#39;, width=1.0) # 设置图表属性 plt.title(\u0026#34;灰度直方图（基于cv2.calcHist）\u0026#34;),plt.xlabel(\u0026#34;像素值 (0-255)\u0026#34;),plt.ylabel(\u0026#34;频次\u0026#34;),plt.xlim([0, 255]) # 限制X轴范围 plt.grid(alpha=1) # 表示网格线是半透明的（30% 不透明） plt.show() # 分别统计这张彩色图的b、g、r plt.figure(figsize=(10, 2)) color = (\u0026#39;b\u0026#39;,\u0026#39;g\u0026#39;,\u0026#39;r\u0026#39;) # 通过for循环，将不同颜色进行统计，绘制在三张图上，最后将三张图统一展示。 for i, col in enumerate(color): # enumerate可以同时得到索引和数据 hist = cv2.calcHist([image1], [i], None, [256], [0, 256]) plt.plot(hist, color=col) plt.xlim([0, 256]) plt.show() musk的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 %matplotlib inline import numpy as np import cv2 import matplotlib.pyplot as plt # 设置中文字体 plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False image= cv2.imread(\u0026#39;./pictures/GEM.png\u0026#39;, cv2.IMREAD_GRAYSCALE) musk = np.zeros(image.shape[:2],np.uint8) musk[100:300,100:400] = 255 # 把保存的东西设置为255 hist = cv2.calcHist([image],[0],musk,[256],[0,256]) plt.figure(figsize=(10, 2)) plt.plot(hist) plt.xlim([0,256]) plt.show() 均衡化与自适应均衡化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import numpy as np import cv2 import matplotlib.pyplot as plt # 设置中文字体 plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False image= cv2.imread(\u0026#39;./pictures/GEM.png\u0026#39;, cv2.IMREAD_GRAYSCALE) musk = np.zeros(image.shape[:2],np.uint8) musk[100:300,100:400] = 255 hist = cv2.calcHist([image],[0],musk,[256],[0,256]) a = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8)) res_clahe = a.apply(image) equ = cv2.equalizeHist(image) plt.figure(figsize=(8, 2)) plt.subplot(122),plt.imshow(res_clahe,cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#34;自适应均衡化\u0026#34;) plt.subplot(121),plt.imshow(equ,cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#34;均衡化\u0026#34;) plt.show() 低通与高通滤波 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import cv2 import numpy as np import matplotlib.pyplot as plt # 设置中文字体 plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False image = cv2.imread(\u0026#39;./pictures/GEM.png\u0026#39;, cv2.IMREAD_GRAYSCALE)#读取图像 image_float32 = np.float32(image) # 转化格式为np.float32 a = cv2.dft(image_float32, flags=cv2.DFT_COMPLEX_OUTPUT) # 进行频域变化 a_shift = np.fft.fftshift(a) # 将低频值放到中心处 img2 = 20*np.log(cv2.magnitude(a_shift[:,:,0], a_shift[:,:,1])) # 转化为灰度图可以展示的图像 rows, cols = image.shape crow, ccol = int(rows / 2), int(cols / 2) # 低通滤波器(会使得图像变模糊) musk = np.zeros((rows, cols,2),np.uint8) musk[crow-30:crow+30, ccol-30:ccol+30] = 1 # IDFT fshift = a_shift*musk f_shift = np.fft.ifftshift(fshift) # 还原这一步操作：“将低频值放到中心处” img = cv2.idft(f_shift) img = cv2.magnitude(img[:,:,0], img[:,:,1]) # 把实部与虚部分开 # 高通滤波器 musk2 = np.ones((rows, cols,2),np.uint8) musk2[crow-30:crow+30, ccol-30:ccol+30] = 0 fshift2 = a_shift*musk2 f_shift2 = np.fft.ifftshift(fshift2) img2 = cv2.idft(f_shift2) img2 = cv2.magnitude(img2[:,:,0], img2[:,:,1]) plt.subplot(221),plt.imshow(img2, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#34;频域图\u0026#34;) plt.subplot(222),plt.imshow(image, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#34;原始图像\u0026#34;) plt.subplot(223),plt.imshow(img, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#34;低通滤波器\u0026#34;) plt.subplot(224),plt.imshow(img2, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#34;高通滤波器\u0026#34;) plt.show() 角点检测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 %matplotlib inline import cv2 import numpy as np import matplotlib.pyplot as plt # 设置中文字体 plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False def show(img): cv2.imshow(\u0026#34;topic:zhenquanxu1\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() image = cv2.imread(\u0026#34;./pictures/guojixiangqi_qipan.jpg\u0026#34;) image_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) image_gray_32 = np.float32(image_gray) # ！！！注意要求把灰度图转化为np.float32格式的，这很重要！！！ dst = cv2.cornerHarris(image_gray_32, 2, 3, 0.04) # 固定用法 image[dst \u0026gt; 0.01 * dst.max()] = [0, 0, 255] # 固定用法，用于筛选出响应值大于最大响应值 1% 的像素点，这些像素点被认为是角点 plt.imshow(image),plt.title(\u0026#34;角点检测\u0026#34;) plt.show() .SIFT函数检测特征点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 %matplotlib inline import cv2 import numpy as np import matplotlib.pyplot as plt plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False def show(img): cv2.imshow(\u0026#34;topic:zhenquanxu1\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() # 图像读取与预处理 image = cv2.imread(\u0026#34;./pictures/GEM.png\u0026#34;) image_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) # 得到特征点（key points） sift = cv2.xfeatures2d.SIFT_create() kp = sift.detect(image_gray, None) # 传入的是灰度图 # 绘制特征点 image = cv2.drawKeypoints(image_gray, kp, image, color=(0, 255, 0)) # 输出图片 plt.subplot(),plt.imshow(image, cmap=\u0026#39;gray\u0026#39;),plt.title(\u0026#34;SIFT特征点\u0026#34;),plt.show() # 计算特征 kp,des = sift.compute(image_gray, kp) print(np.array(kp).shape) # 特征点的个数 print(des.shape) # 每一个特征点都是一个128维的向量 print(des[0]) # 每一个特征点都是一个128维的向量，可以数一下是128维 Brute-Force蛮力匹配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 %matplotlib inline import numpy as np import matplotlib.pyplot as plt import cv2 plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False def show(img): cv2.imshow(\u0026#34;topic:zhenquanxu1\u0026#34;, img) cv2.waitKey(0) cv2.destroyAllWindows() image1 = cv2.imread(\u0026#34;./pictures/GEM_face.png\u0026#34;) image2 = cv2.imread(\u0026#34;./pictures/GEM.png\u0026#34;) sift = cv2.xfeatures2d.SIFT_create() kp1, des1 = sift.detectAndCompute(image1, None) # 找到特征点与特征向量 kp2, des2 = sift.detectAndCompute(image2, None) # 找到特征点与特征向量 bf1 = cv2.BFMatcher(crossCheck=True) # 1对1的匹配 matches = bf1.match(des1, des2) matches = sorted(matches, key=lambda x: x.distance) image3 = cv2.drawMatches(image1, kp1, image2, kp2, matches[:10], None, flags=2) # k对最佳匹配 bf2 = cv2.BFMatcher() matches2 = bf2.knnMatch(des1,des2,2) good = [] for m, n in matches2: if m.distance \u0026lt; 0.75*n.distance: good.append(m) image4 = cv2.drawMatches(image1, kp1, image2, kp2, good, None, flags=2) # 展示图片 image3_rgb = image3[:, :, ::-1] # 把BGR图片转化为RGB图片 image4_rgb = image4[:, :, ::-1] # 把BGR图片转化为RGB图片 plt.subplot(221),plt.imshow(image3_rgb),plt.title(\u0026#34;1对1的匹配\u0026#34;) plt.subplot(222),plt.imshow(image4_rgb),plt.title(\u0026#34;k对最佳匹配\u0026#34;) plt.show() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 %matplotlib inline import cv2 import numpy as np import matplotlib.pyplot as plt plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False imageA = cv2.imread(\u0026#34;./pictures/p1.png\u0026#34;) imageB = cv2.imread(\u0026#34;./pictures/p2.png\u0026#34;) gray1 = cv2.cvtColor(imageA, cv2.COLOR_BGR2GRAY) gray2 = cv2.cvtColor(imageB, cv2.COLOR_BGR2GRAY) sift = cv2.xfeatures2d.SIFT_create() kpsA,dpA = sift.detectAndCompute(gray1, None) kpsB,dpB = sift.detectAndCompute(gray2, None) bf = cv2.BFMatcher() matches = bf.knnMatch(dpA,dpB,2) good = [] for m in matches: if len(m) == 2 and m[0].distance \u0026lt; m[1].distance * 0.75: good.append((m[0].queryIdx,m[0].trainIdx)) kps1 = np.float32([kp.pt for kp in kpsA]) kps2 = np.float32([kp.pt for kp in kpsB]) kps1 = np.float32([kps1[a[0]] for a in good]) kps2 = np.float32([kps2[a[1]] for a in good]) M,status = cv2.findHomography(kps2,kps1,cv2.RANSAC,4.0) result = cv2.warpPerspective(imageB, M, (imageA.shape[1]+imageB.shape[1],imageA.shape[0])) result[0:imageA.shape[0],0:imageA.shape[1]] = imageA # 计算变换后的图像B的边界 h, w = imageB.shape[:2] corners = np.array([[0, 0], [0, h-1], [w-1, h-1], [w-1, 0]], dtype=np.float32) warped_corners = cv2.perspectiveTransform(corners.reshape(1, -1, 2), M).reshape(-1, 2) # 计算输出画布的最小包围矩形 all_corners = np.concatenate((warped_corners, np.array([[0,0], [imageA.shape[1], imageA.shape[0]]])), axis=0) x_min, y_min = np.floor(np.min(all_corners, axis=0)).astype(int) x_max, y_max = np.ceil(np.max(all_corners, axis=0)).astype(int) # 计算平移变换矩阵 offset_x = -x_min offset_y = -y_min translation_matrix = np.array([[1, 0, offset_x], [0, 1, offset_y], [0, 0, 1]]) # 调整单应性矩阵并执行透视变换 adjusted_homography = translation_matrix.dot(M) result = cv2.warpPerspective(imageB, adjusted_homography, (x_max - x_min, y_max - y_min)) # 创建新的拼接画布 result[offset_y:offset_y+imageA.shape[0], offset_x:offset_x+imageA.shape[1]] = imageA # 自动裁剪黑边 gray = cv2.cvtColor(result, cv2.COLOR_BGR2GRAY) _, thresh = cv2.threshold(gray, 1, 255, cv2.THRESH_BINARY) _,contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) x,y,w,h = cv2.boundingRect(contours[0]) final = result[y:y+h, x:x+w] # 展示图片 final_rgb = final[:, :, ::-1] # 把BGR图片转化为RGB图片 imageA_rgb = imageA[:, :, ::-1]# 把BGR图片转化为RGB图片 imageB_rgb = imageB[:, :, ::-1]# 把BGR图片转化为RGB图片 plt.subplot(131),plt.imshow(imageA_rgb),plt.title(\u0026#34;左边的图片\u0026#34;) plt.subplot(132),plt.imshow(imageB_rgb),plt.title(\u0026#34;右边的图片\u0026#34;) plt.subplot(133),plt.imshow(final_rgb),plt.title(\u0026#34;拼接后的图片\u0026#34;) plt.show() ","date":"2025-04-13T14:47:46+08:00","permalink":"http://localhost:1313/p/opencv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"opencv学习笔记"},{"content":"平静的乡村 ​ ​乡村是一口老井，井壁上交织着新与旧，斑驳着昨天与今天。\n​ 乡村的生活是平静的，没有什么事可以引起波澜，甚至是生命的离逝。乡村如同冷酷的哲人，目睹生命的交替与时光的流转。在里面，你不得不感叹自己的弱小与无助，渴望那份喧闹那份所谓的热闹，渴望有亲人倍伴的充实，但事实骨感。在春冬交替中默默走完自己的一生，这一生你可能外出生活过，流连于大都市的美，但老了你一定是要回到儿时的那个老家，这也许是落叶归根吧，也许你会感喟时光之快，感叹自己没有奋斗，气愤自己虚度了时光，但你还是要走古人也走过的路，走后人也要走的路——死亡路。你走了，甚至轻到没有一片树叶为你落下，没有什么东西证明你存在过，多少人不是如此，相信我也会如此。\n​ 生命是极短暂的，把握好当下，让明天的你看得起今天的你。\n关于孤独的思考 ​ 孤独来源于个体与外界的分隔，这分隔包括肉体上和精神上的。这孤独可能是主动的也可能是被动的，但无论如何我们孤独的时间一定长于不孤独的时间。在这漫长的孤独中，有的人焦虑、恐惧、寻找、麻木、成长，于是乎孤独也就被赋予了不同的意义。\n​ 孤独让人真正的直面丑陋、浅薄、无知的自己，当然这直面的行为是被动的，当褪去外界虚假的喧闹的绚烂的物质的泡沫外衣，我们惶恐的不安的看着自己空虚的内心，茫茫然不知何为，于是陷入虚无主义中，当然绝对的虚无主义是不自洽的，当你认为任何东西都没有意义时这句话不也是有意义的吗，我们在孤独中陷入的虚无主义更多的反应的是对自我的逃避、对外界喧闹的渴望罢了。\n​ 你又怎么会长时间的孤独，我们还是要吃饭的呀，生活逼迫着我们谋生、逼着我们忙碌，在劳动中精神从孤独中脱离，之前的一切虚无似乎被金钱赋予了意义，我们怎会真正去长时间直面自己、思考人生，当我们真正满足了自己的物质需求时大约已经是年迈了，这是一件多么可悲的事情啊。\n​ 当然，我不是反对追求物质生活，尼采认为：人做一切事情要从自己出​ ​ 过去的事情已经远去，将来的事还未发生，我们能把握的只有当下。\n关于善良的思考 ​ 善恶的区分不是从自身出发的。假如善恶立足于个人，那么根据惯性思维对自己好的一定是善而对自己坏的一定是恶的，那么自杀的人就是最坏的人，因为对于我们来说没有什么比丧失生命更坏的结果了。但是，我们大众却感叹生命的脆弱和无力，没有人对这个坏人进行批判进行侮辱（批判和侮辱坏人不是我们经常做的吗？），坏人死了我们却没有感到任何的快感、轻松感、愉悦感、胜利感。因此，善恶的观念的区分不是立足于个人。\n​ 善恶的区分立足于集体。从上面的论证出发，善恶的区分不是从自身出发的，在人类生活的地方，无非就是个人与集体，我们无法找到第三种人的组织形式，既然是有善恶的概念既然善恶是存在的，既然我们否认了个人善恶观念，那么善恶一定是从集体出发的。\n​ 对集体有利的是善的，对集体有害的是恶的。比如中国的雷锋，他经常做好事、做对别人有利的事情，我们称他为良善之人，他做到了维护或者帮助实现了部分人的利益也就是集体的利益（一个人不可能只凭借自己而不依赖他人实现对全部人类的利益）。但是这里的集体又是什么？这里的部分人又是什么？我认为这里的集体、部分人的决定权掌握在当前的统治者手中，统治者决定了你的行为是否对集体有利。而且当统治者的认为的良善与个人所认为的良善冲突时，个人的力量无法战胜统治者的力量。统治者宣传的什么是善什么是恶会在潜移默化中改变着个人的观念，这也就是洗脑吧。当然统治者宣传的有对的也会有错的。（这里的对错在当下是无法区分的，只有站在历史车辙印之前去回看那个时间的宣传才能有所辨别吧）\n​ 那伤害自己是善还是恶？我们知道善恶的区分是基于集体的，伤害自己对集体有利就是善的，伤害自己对集体有害就是恶的，这些是显而易见的，但是伤害自己对集体是中性的呢？我们不妨称之为一种解脱，这种人跳出了集体的约束，真正有了自己的想法，善恶对他来说只不过是当权者用来压制下层百姓的手段。\n​ 当下人人都要追求良善，我们不放假想一种情况就是人人都是良善的人，没有邪恶了，这个时候会发生什么？这大概就像是时间里缺失了黑夜，小溪中缺失了污泥，这个社会完全就是一种死去的物品，毫无个性，个人完全服从于集体，因为我们承认善良就是集体的利益，而集体的利益由统治者决定，也就是说，缺失邪恶的社会就是一个独裁的时代，每个人是麻木的行尸走肉。社会只有在与所谓的邪恶斗争时才会向前进步，而且没有尽头。\n​ 旷野，漆黑，微风。\n追求纯粹，仰望星空 ​ 思绪纷飞，遂记。\n​ 罗翔老师曾经说过：“虚无主义者在逻辑上是不自洽的，因为你认为所有事都没有意义那么必然有一个确定的意义存在”，我又陷入虚无主义的陷阱中了，我怀疑我所从事的事、所追求的理想、甚至我的人生是否有一个确定的意义。\n​ 余华的《活着》告诉我们——活着是为了活着。就我有限或者可以称为偏见的观点来看，这句话是否带有功利主义的色彩，这句话功利的将人的活着看作手段，借由这手段实现活着的目的。我当然不认同这观点，我仍然固执的相信生命中有更加纯粹的东西值得我们追求，这东西比生命更珍贵。当一个人拥有了这纯粹的追求，就如子贡问询孔子的那个夜晚，孔子的回答“君子固穷，小人穷斯滥矣”，孔子一行人不辞辛劳的游说于大国之间，履行着上天所赋予他们的天命，这天命又怎不是孔子的纯粹的追求呢？再如颜回“一箪食一瓢饮，人也不堪其忧，回也不改其乐也”，这或许就是颜回的纯粹的追求吧。这纯粹是文学的高贵，是数学家苦苦的求索，是引领人类的我们头顶灿烂的星空所散发出的光芒。\n​ 或许我也有我要追求的纯粹的东西吧。\n心怀温暖，谦卑向上 ​ 走了许久的路，深知自己的渺小，深知自己的偏激。思索良久，遂撰此文，希望记录下当前的思想历程。\n​ 如题，我将“心怀温暖”放在首位。我希望自己成为一个有温度，懂生活的人，而不是一个迷失在无限欲望的“死人”。我知道我注定平凡甚至平庸，我也一定会成为我曾经所耻的荟荟众生，整天忙碌于柴米油盐，为鸡毛蒜皮的小事而伤神。但我不想我错过平凡生活中的美好，不懂春风的妩媚，夏树的强健、秋叶的留恋，冬雪的凌冽，我不想面对着圆月无所感慨，不想变成一个无趣的大人，不想我的愉乐活动是打游戏、刷短视频，看网络小说。我要心怀温暖，记录下每个小感动，用心经营这平淡如水的日子。\n​ 如题，我将“谦卑”放在第二位。我希望自己成为真正的“谦谦君子”而不是言必称君子，行必为小人，我不希望自己迷失在别人的称赞中，我希望自己谦卑就是希望自己对自己有一个清醒的认知，正确看待别人的指责。\n​ 最后，我将向上”放在第三位。”“向上”似乎有更具体的要求，向上就是脱离贫困、物质丰盈、生活得体面。实现物质的富足似乎功利了，但只要合乎道义孔子也支持。物质富足要且不得不奋斗，要受很多挫折，要流汗、要流泪甚至流血的，更不要说社会大环境如此衰败，大家都得争抢不多的资源。“向上”很难，但是我也要参与，我要经历，我不能也无法做一个旁观者。我现在是不敢奋斗，害怕失败甚至质疑奋斗的意义，是啊，我没有经历过我没有资格谈失败，须知奋斗永不过时。\n​ 愿我自己摆脱颓丧之气，心怀温暖谦卑向上。\n未知死，何知生？ ","date":"2025-04-13T00:00:00Z","image":"http://localhost:1313/p/%E4%B8%80%E8%8C%B6%E4%B8%80%E9%A5%AD%E8%BF%87%E4%B8%80%E7%94%9F/02_hu_51eb0b49dce9a09c.jpg","permalink":"http://localhost:1313/p/%E4%B8%80%E8%8C%B6%E4%B8%80%E9%A5%AD%E8%BF%87%E4%B8%80%E7%94%9F/","title":"一茶一饭过一生"}]